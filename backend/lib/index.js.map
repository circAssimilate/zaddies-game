{
  "version": 3,
  "sources": ["../src/functions/index.ts", "../src/functions/game/createTable.ts", "../src/functions/game/schemas.ts", "../src/lib/utils/codeGenerator.ts", "../src/functions/game/joinTable.ts", "../src/functions/game/leaveTable.ts"],
  "sourcesContent": ["/**\n * Firebase Cloud Functions entry point\n * Contract: specs/001-texas-holdem-poker/contracts/api-functions.md\n */\n\nimport admin from 'firebase-admin';\nimport { onCall } from 'firebase-functions/v2/https';\nimport { createTable } from './game/createTable';\nimport { joinTable } from './game/joinTable';\nimport { leaveTable } from './game/leaveTable';\n\n// Initialize Firebase Admin\nadmin.initializeApp();\n\n// ============================================================================\n// Table Management Functions\n// ============================================================================\n\n/**\n * Create Table\n * Creates a new poker table with unique 4-digit code\n */\nexport const createTableFunction = onCall({ cors: true }, async request => {\n  return createTable(request.data, request);\n});\n\n/**\n * Join Table\n * Join an existing table with 4-digit code\n */\nexport const joinTableFunction = onCall({ cors: true }, async request => {\n  return joinTable(request.data, request);\n});\n\n/**\n * Leave Table\n * Leave a table and automatically cash out chips\n */\nexport const leaveTableFunction = onCall({ cors: true }, async request => {\n  return leaveTable(request.data, request);\n});\n\n// TODO: Export additional functions as they are implemented\n// - startGame\n// - playerAction\n// - buyChips\n// - cashOut\n// - getLedger\n// - generateShareableView\n// - getHandHistory\n", "/**\n * createTable Cloud Function\n * Contract: specs/001-texas-holdem-poker/contracts/api-functions.md\n *\n * Creates a new poker table with unique 4-digit code\n */\n\nimport { HttpsError } from 'firebase-functions/v2/https';\nimport { getFirestore } from 'firebase-admin/firestore';\nimport type { CreateTableRequest, CreateTableResponse } from './types';\nimport { createTableDocument } from './schemas';\nimport { generateTableCode } from '../../lib/utils/codeGenerator';\n\n/**\n * Create Table Function\n * @param data - CreateTableRequest\n * @param context - Call context with auth\n * @returns CreateTableResponse\n */\nexport async function createTable(\n  data: CreateTableRequest,\n  context: { auth?: { uid: string } }\n): Promise<CreateTableResponse> {\n  // Validate authentication\n  if (!context.auth) {\n    throw new HttpsError('unauthenticated', 'User must be authenticated to create a table');\n  }\n\n  const userId = context.auth.uid;\n  const db = getFirestore();\n\n  try {\n    // Validate settings if provided\n    if (data.settings) {\n      validateTableSettings(data.settings);\n    }\n\n    // Generate unique 4-digit table code\n    const tableId = await generateTableCode(db);\n\n    // Create table document\n    const tableDoc = createTableDocument(tableId, userId, data.settings);\n\n    // Save to Firestore\n    await db.collection('tables').doc(tableId).set(tableDoc);\n\n    return {\n      success: true,\n      tableId,\n      message: 'Table created successfully',\n    };\n  } catch (error) {\n    // Handle specific errors\n    if (error instanceof HttpsError) {\n      throw error;\n    }\n\n    // Handle validation errors\n    if (error instanceof Error && error.message.includes('blind')) {\n      throw new HttpsError('invalid-argument', error.message);\n    }\n\n    if (error instanceof Error && error.message.includes('players')) {\n      throw new HttpsError('invalid-argument', error.message);\n    }\n\n    if (error instanceof Error && error.message.includes('buy-in')) {\n      throw new HttpsError('invalid-argument', error.message);\n    }\n\n    if (error instanceof Error && error.message.includes('stack')) {\n      throw new HttpsError('invalid-argument', error.message);\n    }\n\n    // Handle code generation exhaustion\n    if (error instanceof Error && error.message.includes('Unable to generate')) {\n      throw new HttpsError(\n        'resource-exhausted',\n        'Unable to generate unique table code. Please try again.'\n      );\n    }\n\n    // Generic error\n    throw new HttpsError('internal', 'Failed to create table');\n  }\n}\n\n/**\n * Validate table settings\n * @param settings - Partial table settings\n * @throws HttpsError if settings are invalid\n */\nfunction validateTableSettings(settings: CreateTableRequest['settings']) {\n  if (!settings) return;\n\n  // Validate maxPlayers\n  if (settings.maxPlayers !== undefined) {\n    if (settings.maxPlayers < 2 || settings.maxPlayers > 10) {\n      throw new HttpsError('invalid-argument', 'Max players must be between 2 and 10');\n    }\n  }\n\n  // Validate blinds\n  if (settings.bigBlind !== undefined && settings.bigBlind <= 0) {\n    throw new HttpsError('invalid-argument', 'Big blind must be positive');\n  }\n\n  if (settings.smallBlind !== undefined && settings.smallBlind <= 0) {\n    throw new HttpsError('invalid-argument', 'Small blind must be positive');\n  }\n\n  // Validate small blind < big blind\n  if (\n    settings.smallBlind !== undefined &&\n    settings.bigBlind !== undefined &&\n    settings.smallBlind >= settings.bigBlind\n  ) {\n    throw new HttpsError('invalid-argument', 'Small blind must be less than big blind');\n  }\n\n  // Validate minBuyIn\n  if (settings.minBuyIn !== undefined && settings.minBuyIn <= 0) {\n    throw new HttpsError('invalid-argument', 'Minimum buy-in must be positive');\n  }\n\n  // Validate maxStack\n  if (settings.maxStack !== undefined && settings.maxStack <= 0) {\n    throw new HttpsError('invalid-argument', 'Maximum stack must be positive');\n  }\n\n  // Validate maxStack >= minBuyIn\n  if (\n    settings.maxStack !== undefined &&\n    settings.minBuyIn !== undefined &&\n    settings.maxStack < settings.minBuyIn\n  ) {\n    throw new HttpsError(\n      'invalid-argument',\n      'Maximum stack must be greater than or equal to minimum buy-in'\n    );\n  }\n\n  // Validate maxDebtPerPlayer\n  if (settings.maxDebtPerPlayer !== undefined && settings.maxDebtPerPlayer < 0) {\n    throw new HttpsError('invalid-argument', 'Maximum debt per player cannot be negative');\n  }\n\n  // Validate actionTimer\n  if (settings.actionTimer !== undefined && settings.actionTimer <= 0) {\n    throw new HttpsError('invalid-argument', 'Action timer must be positive');\n  }\n\n  // Validate blindIncreaseInterval\n  if (settings.blindIncreaseInterval !== undefined && settings.blindIncreaseInterval <= 0) {\n    throw new HttpsError('invalid-argument', 'Blind increase interval must be positive');\n  }\n}\n", "/**\n * Firestore Collection Schemas for Game Logic\n * Contract: specs/001-texas-holdem-poker/contracts/firestore-schema.md\n *\n * These schemas define the structure of documents in Firestore.\n * They are used for validation and type safety.\n */\n\nimport { Timestamp } from 'firebase-admin/firestore';\nimport type { PlayerState } from '@shared/types/player';\nimport type { TableSettings, TableStatus } from '@shared/types/table';\nimport type { Card } from '@shared/types/game';\n\n// ============================================================================\n// Player Schema\n// ============================================================================\n\n/**\n * Player document in /players/{playerId}\n * Contract: specs/001-texas-holdem-poker/contracts/firestore-schema.md\n */\nexport interface PlayerDocument {\n  id: string; // Firebase Auth UID (immutable)\n  username: string; // Display name (mutable)\n  email: string; // From Firebase Auth (immutable)\n  createdAt: Timestamp; // Account creation (immutable)\n  lastSeen: Timestamp; // Last login (mutable)\n  stats?: {\n    totalChipsBought: number;\n    totalChipsCashedOut: number;\n    handsPlayed: number;\n  };\n}\n\n/**\n * Validate Player document\n */\nexport function validatePlayerDocument(data: unknown): PlayerDocument {\n  const player = data as Partial<PlayerDocument>;\n\n  if (!player.id || typeof player.id !== 'string') {\n    throw new Error('Player.id is required and must be a string');\n  }\n\n  if (!player.username || typeof player.username !== 'string') {\n    throw new Error('Player.username is required and must be a string');\n  }\n\n  if (!player.email || typeof player.email !== 'string') {\n    throw new Error('Player.email is required and must be a string');\n  }\n\n  if (!player.createdAt || !(player.createdAt instanceof Timestamp)) {\n    throw new Error('Player.createdAt is required and must be a Timestamp');\n  }\n\n  if (!player.lastSeen || !(player.lastSeen instanceof Timestamp)) {\n    throw new Error('Player.lastSeen is required and must be a Timestamp');\n  }\n\n  return player as PlayerDocument;\n}\n\n/**\n * Create default Player document\n */\nexport function createPlayerDocument(id: string, username: string, email: string): PlayerDocument {\n  const now = Timestamp.now();\n\n  return {\n    id,\n    username,\n    email,\n    createdAt: now,\n    lastSeen: now,\n    stats: {\n      totalChipsBought: 0,\n      totalChipsCashedOut: 0,\n      handsPlayed: 0,\n    },\n  };\n}\n\n// ============================================================================\n// Table Schema\n// ============================================================================\n\n/**\n * Table document in /tables/{tableId}\n * Contract: specs/001-texas-holdem-poker/contracts/firestore-schema.md\n */\nexport interface TableDocument {\n  id: string; // 4-digit code (e.g., \"1234\")\n  hostId: string; // Current host player ID\n  status: TableStatus; // 'waiting' | 'playing' | 'ended'\n  settings: TableSettings;\n  players: PlayerState[]; // Array of players at table\n  createdAt: Timestamp;\n  hand: HandState | null; // Current hand state (null when not playing)\n  blindLevel: number; // Current blind level (for tournaments)\n  lastBlindIncrease: Timestamp | null; // When blinds last increased\n}\n\n/**\n * Hand state embedded in Table document\n */\nexport interface HandState {\n  handNumber: number;\n  phase: 'preflop' | 'flop' | 'turn' | 'river' | 'showdown';\n  dealerPosition: number;\n  smallBlindPosition: number;\n  bigBlindPosition: number;\n  currentPlayerPosition: number;\n  communityCards: Card[];\n  pot: number;\n  sidePots: SidePot[];\n  currentBet: number;\n  actions: ActionHistory[];\n}\n\nexport interface SidePot {\n  amount: number;\n  eligiblePlayers: string[]; // Player IDs\n}\n\nexport interface ActionHistory {\n  playerId: string;\n  action: 'fold' | 'check' | 'call' | 'raise' | 'allin';\n  amount: number;\n  timestamp: Timestamp;\n}\n\n/**\n * Validate Table document\n */\nexport function validateTableDocument(data: unknown): TableDocument {\n  const table = data as Partial<TableDocument>;\n\n  if (!table.id || !/^\\d{4}$/.test(table.id)) {\n    throw new Error('Table.id must be a 4-digit string');\n  }\n\n  if (!table.hostId || typeof table.hostId !== 'string') {\n    throw new Error('Table.hostId is required and must be a string');\n  }\n\n  if (!table.status || !['waiting', 'playing', 'ended'].includes(table.status)) {\n    throw new Error('Table.status must be one of: waiting, playing, ended');\n  }\n\n  if (!table.settings) {\n    throw new Error('Table.settings is required');\n  }\n\n  if (!Array.isArray(table.players)) {\n    throw new Error('Table.players must be an array');\n  }\n\n  if (!table.createdAt || !(table.createdAt instanceof Timestamp)) {\n    throw new Error('Table.createdAt is required and must be a Timestamp');\n  }\n\n  return table as TableDocument;\n}\n\n/**\n * Create default Table document\n */\nexport function createTableDocument(\n  tableId: string,\n  hostId: string,\n  settings?: Partial<TableSettings>\n): TableDocument {\n  const defaultSettings: TableSettings = {\n    maxPlayers: 10,\n    minBuyIn: 100,\n    maxStack: 2000,\n    maxDebtPerPlayer: 1000,\n    smallBlind: 5,\n    bigBlind: 10,\n    blindIncreaseInterval: 15, // minutes\n    actionTimer: 30, // seconds\n    showHandStrength: false,\n  };\n\n  const finalSettings: TableSettings = {\n    ...defaultSettings,\n    ...settings,\n  };\n\n  // Validate settings\n  if (finalSettings.smallBlind >= finalSettings.bigBlind) {\n    throw new Error('Small blind must be less than big blind');\n  }\n\n  if (finalSettings.maxPlayers < 2 || finalSettings.maxPlayers > 10) {\n    throw new Error('Max players must be between 2 and 10');\n  }\n\n  if (finalSettings.minBuyIn <= 0) {\n    throw new Error('Min buy-in must be positive');\n  }\n\n  if (finalSettings.maxStack < finalSettings.minBuyIn) {\n    throw new Error('Max stack must be greater than min buy-in');\n  }\n\n  const now = Timestamp.now();\n\n  return {\n    id: tableId,\n    hostId,\n    status: 'waiting',\n    settings: finalSettings,\n    players: [],\n    createdAt: now,\n    hand: null,\n    blindLevel: 1,\n    lastBlindIncrease: null,\n  };\n}\n\n// ============================================================================\n// Ledger Schema\n// ============================================================================\n\n/**\n * Ledger entry document in /ledger/{playerId}/transactions/{transactionId}\n * Contract: specs/001-texas-holdem-poker/contracts/firestore-schema.md\n */\nexport interface LedgerEntryDocument {\n  id: string; // Auto-generated\n  playerId: string; // Player reference\n  type: 'buy' | 'cashout';\n  amount: number; // Chips (buy=negative, cashout=positive)\n  tableId: string | null;\n  timestamp: Timestamp;\n  runningBalance: number; // Cumulative balance\n}\n\n/**\n * Create ledger entry\n */\nexport function createLedgerEntry(\n  playerId: string,\n  type: 'buy' | 'cashout',\n  amount: number,\n  runningBalance: number,\n  tableId: string | null = null\n): LedgerEntryDocument {\n  return {\n    id: '', // Will be set by Firestore auto-ID\n    playerId,\n    type,\n    amount,\n    tableId,\n    timestamp: Timestamp.now(),\n    runningBalance,\n  };\n}\n\n// ============================================================================\n// Player Hand Schema (Private hole cards)\n// ============================================================================\n\n/**\n * Player hand document in /tables/{tableId}/hands/{handNumber}/playerHands/{playerId}\n * Contract: specs/001-texas-holdem-poker/contracts/firestore-schema.md\n */\nexport interface PlayerHandDocument {\n  playerId: string;\n  holeCards: [Card, Card];\n  handNumber: number;\n}\n\n/**\n * Create player hand document\n */\nexport function createPlayerHandDocument(\n  playerId: string,\n  holeCards: [Card, Card],\n  handNumber: number\n): PlayerHandDocument {\n  return {\n    playerId,\n    holeCards,\n    handNumber,\n  };\n}\n\n// ============================================================================\n// Hand History Schema\n// ============================================================================\n\n/**\n * Hand history entry in /tables/{tableId}/history/{handNumber}\n * Contract: specs/001-texas-holdem-poker/contracts/firestore-schema.md\n */\nexport interface HandHistoryDocument {\n  handNumber: number;\n  winnerId: string;\n  pot: number;\n  winningHand: string;\n  communityCards: Card[];\n  timestamp: Timestamp;\n  players: {\n    id: string;\n    holeCards: [Card, Card] | null; // null if folded before showdown\n    finalChips: number;\n  }[];\n}\n\n/**\n * Create hand history document\n */\nexport function createHandHistoryDocument(\n  handNumber: number,\n  winnerId: string,\n  pot: number,\n  winningHand: string,\n  communityCards: Card[],\n  players: { id: string; holeCards: [Card, Card] | null; finalChips: number }[]\n): HandHistoryDocument {\n  return {\n    handNumber,\n    winnerId,\n    pot,\n    winningHand,\n    communityCards,\n    timestamp: Timestamp.now(),\n    players,\n  };\n}\n", "/**\n * 4-Digit Table Code Generator\n * Generates unique 4-digit codes for tables\n */\n\nimport { Firestore } from 'firebase-admin/firestore';\n\n/**\n * Generate a unique 4-digit table code\n * @param db - Firestore instance\n * @param maxAttempts - Maximum number of attempts to generate unique code\n * @returns Promise<string> - 4-digit code (e.g., \"1234\")\n * @throws Error if unable to generate unique code after maxAttempts\n */\nexport async function generateTableCode(db: Firestore, maxAttempts = 10): Promise<string> {\n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    // Generate random 4-digit code (1000-9999)\n    const code = Math.floor(1000 + Math.random() * 9000).toString();\n\n    // Check if code is already in use\n    const tableDoc = await db.collection('tables').doc(code).get();\n\n    if (!tableDoc.exists) {\n      return code;\n    }\n  }\n\n  throw new Error(`Unable to generate unique table code after ${maxAttempts} attempts`);\n}\n\n/**\n * Validate table code format\n * @param code - Code to validate\n * @returns boolean - true if valid 4-digit code\n */\nexport function isValidTableCode(code: string): boolean {\n  return /^\\d{4}$/.test(code);\n}\n\n/**\n * Check if table code exists\n * @param db - Firestore instance\n * @param code - Table code to check\n * @returns Promise<boolean> - true if code exists\n */\nexport async function tableCodeExists(db: Firestore, code: string): Promise<boolean> {\n  if (!isValidTableCode(code)) {\n    return false;\n  }\n\n  const tableDoc = await db.collection('tables').doc(code).get();\n  return tableDoc.exists;\n}\n", "/**\n * joinTable Cloud Function\n * Contract: specs/001-texas-holdem-poker/contracts/api-functions.md\n *\n * Allows players to join existing tables with 4-digit codes\n */\n\nimport { HttpsError } from 'firebase-functions/v2/https';\nimport { getFirestore, Timestamp, FieldValue } from 'firebase-admin/firestore';\nimport type { JoinTableRequest, JoinTableResponse } from './types';\nimport type { TableDocument } from './schemas';\nimport type { PlayerState } from '@shared/types/player';\nimport { createLedgerEntry, createPlayerDocument } from './schemas';\n\n/**\n * Join Table Function\n * @param data - JoinTableRequest\n * @param context - Call context with auth\n * @returns JoinTableResponse\n */\nexport async function joinTable(\n  data: JoinTableRequest,\n  context: { auth?: { uid: string; token?: { email?: string; name?: string } } }\n): Promise<JoinTableResponse> {\n  // Validate authentication\n  if (!context.auth) {\n    throw new HttpsError('unauthenticated', 'User must be authenticated to join a table');\n  }\n\n  const userId = context.auth.uid;\n  const { tableId, buyInAmount } = data;\n  const db = getFirestore();\n\n  try {\n    // Validate table ID format\n    if (!/^\\d{4}$/.test(tableId)) {\n      throw new HttpsError('invalid-argument', 'Table code must be a 4-digit number');\n    }\n\n    // Validate buy-in amount\n    if (buyInAmount <= 0) {\n      throw new HttpsError('invalid-argument', 'Buy-in amount must be positive');\n    }\n\n    // Use transaction to ensure atomicity\n    const result = await db.runTransaction(async transaction => {\n      // Get table document\n      const tableRef = db.collection('tables').doc(tableId);\n      const tableDoc = await transaction.get(tableRef);\n\n      if (!tableDoc.exists) {\n        throw new HttpsError('not-found', 'Table not found');\n      }\n\n      const table = tableDoc.data() as TableDocument;\n\n      // Validate table status\n      if (table.status === 'ended') {\n        throw new HttpsError('failed-precondition', 'Cannot join a table that has ended');\n      }\n\n      // Validate table is not full\n      if (table.players.length >= table.settings.maxPlayers) {\n        throw new HttpsError('failed-precondition', 'Table is full');\n      }\n\n      // Validate player is not already at table\n      if (table.players.some(p => p.id === userId)) {\n        throw new HttpsError('already-exists', 'You are already at this table');\n      }\n\n      // Validate buy-in amount meets minimum\n      if (buyInAmount < table.settings.minBuyIn) {\n        throw new HttpsError(\n          'invalid-argument',\n          `Buy-in amount must be at least ${table.settings.minBuyIn}`\n        );\n      }\n\n      // Validate buy-in amount does not exceed maximum\n      if (buyInAmount > table.settings.maxStack) {\n        throw new HttpsError(\n          'invalid-argument',\n          `Buy-in amount cannot exceed ${table.settings.maxStack}`\n        );\n      }\n\n      // Get player's current ledger balance\n      const ledgerSnapshot = await transaction.get(\n        db\n          .collection('ledger')\n          .doc(userId)\n          .collection('transactions')\n          .orderBy('timestamp', 'desc')\n          .limit(1)\n      );\n\n      let currentBalance = 0;\n      if (!ledgerSnapshot.empty) {\n        const lastTransaction = ledgerSnapshot.docs[0].data();\n        currentBalance = lastTransaction.runningBalance || 0;\n      }\n\n      // Calculate new balance after purchase\n      const newBalance = currentBalance - buyInAmount;\n\n      // Validate debt limit\n      if (Math.abs(newBalance) > table.settings.maxDebtPerPlayer) {\n        throw new HttpsError(\n          'permission-denied',\n          `This purchase would exceed the maximum debt limit of ${table.settings.maxDebtPerPlayer}`\n        );\n      }\n\n      // Get player document (must read before any writes)\n      const playerRef = db.collection('players').doc(userId);\n      const playerDoc = await transaction.get(playerRef);\n\n      // Find first available seat position\n      const occupiedPositions = new Set(table.players.map(p => p.position));\n      let position = 0;\n      for (let i = 0; i < table.settings.maxPlayers; i++) {\n        if (!occupiedPositions.has(i)) {\n          position = i;\n          break;\n        }\n      }\n\n      // Create player state\n      const playerState: PlayerState = {\n        id: userId,\n        position,\n        chips: buyInAmount,\n        status: 'sitting',\n        isDealer: false,\n        isSmallBlind: false,\n        isBigBlind: false,\n        currentBet: 0,\n        hasActed: false,\n        isFolded: false,\n        isAllIn: false,\n      };\n\n      // Update table with new player\n      transaction.update(tableRef, {\n        players: FieldValue.arrayUnion(playerState),\n      });\n\n      // Create or update player document\n\n      if (!playerDoc.exists) {\n        // Create new player document\n        const email = context.auth?.token?.email || `${userId}@unknown`;\n        const username = context.auth?.token?.name || `Player ${userId.slice(0, 6)}`;\n\n        const newPlayer = createPlayerDocument(userId, username, email);\n        transaction.set(playerRef, newPlayer);\n      } else {\n        // Update lastSeen timestamp\n        transaction.update(playerRef, {\n          lastSeen: Timestamp.now(),\n        });\n      }\n\n      // Create ledger transaction\n      const ledgerEntry = createLedgerEntry(\n        userId,\n        'buy',\n        -buyInAmount, // Negative for chip purchase\n        newBalance,\n        tableId\n      );\n\n      const ledgerRef = db.collection('ledger').doc(userId).collection('transactions').doc(); // Auto-generate ID\n\n      transaction.set(ledgerRef, {\n        ...ledgerEntry,\n        id: ledgerRef.id,\n      });\n\n      return { position, newBalance };\n    });\n\n    return {\n      success: true,\n      position: result.position,\n      message: 'Successfully joined table',\n    };\n  } catch (error) {\n    // Re-throw HttpsErrors\n    if (error instanceof HttpsError) {\n      throw error;\n    }\n\n    // Generic error\n    console.error('Error joining table:', error);\n    throw new HttpsError('internal', 'Failed to join table');\n  }\n}\n", "/**\n * leaveTable Cloud Function\n * Contract: specs/001-texas-holdem-poker/contracts/api-functions.md\n *\n * Allows players to leave tables and automatically cash out chips\n */\n\nimport { HttpsError } from 'firebase-functions/v2/https';\nimport { getFirestore, Timestamp } from 'firebase-admin/firestore';\nimport type { LeaveTableRequest, LeaveTableResponse } from './types';\nimport type { TableDocument } from './schemas';\nimport { createLedgerEntry } from './schemas';\n\n/**\n * Leave Table Function\n * @param data - LeaveTableRequest\n * @param context - Call context with auth\n * @returns LeaveTableResponse\n */\nexport async function leaveTable(\n  data: LeaveTableRequest,\n  context: { auth?: { uid: string } }\n): Promise<LeaveTableResponse> {\n  // Validate authentication\n  if (!context.auth) {\n    throw new HttpsError('unauthenticated', 'User must be authenticated to leave a table');\n  }\n\n  const userId = context.auth.uid;\n  const { tableId } = data;\n  const db = getFirestore();\n\n  try {\n    // Validate table ID format\n    if (!/^\\d{4}$/.test(tableId)) {\n      throw new HttpsError('invalid-argument', 'Table code must be a 4-digit number');\n    }\n\n    // Use transaction to ensure atomicity\n    const result = await db.runTransaction(async transaction => {\n      // Get table document\n      const tableRef = db.collection('tables').doc(tableId);\n      const tableDoc = await transaction.get(tableRef);\n\n      if (!tableDoc.exists) {\n        throw new HttpsError('not-found', 'Table not found');\n      }\n\n      const table = tableDoc.data() as TableDocument;\n\n      // Find player in table\n      const playerIndex = table.players.findIndex(p => p.id === userId);\n\n      if (playerIndex === -1) {\n        throw new HttpsError('failed-precondition', 'You are not at this table');\n      }\n\n      const player = table.players[playerIndex];\n      const chipsToCashOut = player.chips;\n\n      // Remove player from table\n      const updatedPlayers = table.players.filter(p => p.id !== userId);\n\n      // If player is in active hand, fold them\n      // const updatedHand = table.hand; // Will be used when implementing auto-fold logic\n      if (table.hand && !player.isFolded) {\n        // TODO: Implement auto-fold logic when hand state is implemented\n        // For now, just log it\n        console.log(`Player ${userId} auto-folded when leaving table ${tableId}`);\n      }\n\n      // Handle host transfer if leaving player is host\n      let newHostId = table.hostId;\n      if (table.hostId === userId && updatedPlayers.length > 0) {\n        // Transfer host to next player (longest-seated = first in array)\n        newHostId = updatedPlayers[0].id;\n        console.log(`Host transferred from ${userId} to ${newHostId}`);\n      }\n\n      // Update table\n      const tableUpdate: Partial<TableDocument> = {\n        players: updatedPlayers,\n        hostId: newHostId,\n      };\n\n      // If no players left, mark table as ended\n      if (updatedPlayers.length === 0) {\n        tableUpdate.status = 'ended';\n      }\n\n      transaction.update(tableRef, tableUpdate);\n\n      // Get player's current ledger balance\n      const ledgerSnapshot = await transaction.get(\n        db\n          .collection('ledger')\n          .doc(userId)\n          .collection('transactions')\n          .orderBy('timestamp', 'desc')\n          .limit(1)\n      );\n\n      let currentBalance = 0;\n      if (!ledgerSnapshot.empty) {\n        const lastTransaction = ledgerSnapshot.docs[0].data();\n        currentBalance = lastTransaction.runningBalance || 0;\n      }\n\n      // Calculate new balance after cash out\n      const newBalance = currentBalance + chipsToCashOut;\n\n      // Create ledger transaction for cash out\n      const ledgerEntry = createLedgerEntry(\n        userId,\n        'cashout',\n        chipsToCashOut, // Positive for cash out\n        newBalance,\n        tableId\n      );\n\n      const ledgerRef = db.collection('ledger').doc(userId).collection('transactions').doc(); // Auto-generate ID\n\n      transaction.set(ledgerRef, {\n        ...ledgerEntry,\n        id: ledgerRef.id,\n      });\n\n      // Update player's lastSeen timestamp\n      const playerRef = db.collection('players').doc(userId);\n      transaction.update(playerRef, {\n        lastSeen: Timestamp.now(),\n      });\n\n      return { chipsCashedOut: chipsToCashOut, newBalance };\n    });\n\n    return {\n      success: true,\n      chipsCashedOut: result.chipsCashedOut,\n      message: `Successfully left table. Cashed out ${result.chipsCashedOut} chips.`,\n    };\n  } catch (error) {\n    // Re-throw HttpsErrors\n    if (error instanceof HttpsError) {\n      throw error;\n    }\n\n    // Generic error\n    console.error('Error leaving table:', error);\n    throw new HttpsError('internal', 'Failed to leave table');\n  }\n}\n"],
  "mappings": "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",
  "names": ["HttpsError", "getFirestore", "Timestamp", "HttpsError", "getFirestore", "Timestamp", "HttpsError", "getFirestore", "Timestamp", "HttpsError", "getFirestore", "Timestamp"]
}
